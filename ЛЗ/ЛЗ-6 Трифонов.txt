[1] Упражнения раздела 2.5
1) Упражнение 2.24. Какие из следующих определений (если они есть) недопустимы? Почему? Как их исправить?
(a)	int ival = 1.01;
(b) int &rvall = 1.01;
(с)	int &rval2 = ival;
(d) const int &rval3 = 1;

Ответ: b, d - неверны, потому что ссылки должны ссылаться на обьект

2) Упражнение 2.25. Какие из следующих присвоений (если они есть) являются недопустимыми 
(с учетом предыдущих определений)? Если таковые есть, объясните, почему.
(а)	rva12 = 3.14159;
(b) rva12 = rva13;
(с)	ival = rval3;
(d) rval3 = ival;

Ответ: d недопустимо, rval3 константа , которой присвоено значение 1 

3) Упражнение 2.26. В чем разница между определениями (а) и присвоениями (Ь)? 
Какие из них (если есть) недопустимы?
(a)	int ival = 0;	(b) ival = ri;
const int &ri =0;	ri = ival;

Ответ: a, ссылка должна быть инициализирована обьектом. Определение - это предоставление необходимой информации для создания чего-то целиком. Присвоение - это копирование информации из одного источника в другой.

4) Упражнение 2.27. Что отобразит на экране следующий код?
int i, &ri = i; i = 5; ri = 10;
std::cout << i << " " << ri << std::endl;

Ответ: 10 10

[1] Упражнения раздела 4.2.3
5) Упражнение 4.15. Укажите принципиальные различия между указателями и ссылками.

Ответ: Указатель может быть переназначен многократно, ссылка - нет. Можно получить адрес указателя, ссылки - нет. Указатели могуть быть равными NULL.

[1] Упражнения раздела 7.2.2
6) Упражнение 7.7. Объясните различие между параметрами в следующих двух объявлениях.
void f(Т);
void f(Т&);

Ответ: в первом случае Т - копия переменной, во втором используется адрес переменной

7) Упражнение 7.8. Приведите пример случая, когда параметр должен быть ссылочным.
Приведите пример случая, когда параметр не должен быть ссылочным.

Ответ: 
1) ссылочный параметр
void swap(int &a, int &b)
{
    int buf = a;
    a = b;
    b = buf;
}

2) не ссылочный параметр
int nod (int a, int b)
{
    if (b==0)
        return a;
    return nod(b, a%b);
}

8) Упражнение 7.10. Следующая функция хоть и вполне допустима, но менее полезна,
чем могла бы быть. Выявите и устраните ограничения.
bool test(string& s) { return s.empty(); } Написать main для аргументации своего решения

Ответ: 
bool test(const string& s) { return s.empty(); }

int main()
{
    cout << test("stroka");
}

Вызвать функцию можно только для обьекта класса string, код в main привёл бы к ошибке.
Функция получает строковый аргумент как неконстантную ссылку, хотя в функции этот параметр не изменяется.

9) Упражнение 7.11. Когда ссылочные параметры должны быть константными? 
Какие проблемы могут возникнуть, если параметр является обычной ссылкой, 
а какие — если он является константной ссылкой?

Когда ссылочные параметры должны быть константными?
Ответ: константами должны быть параметры, которые не измеяются

Какие проблемы могут возникнуть, если параметр является обычной ссылкой, 
а какие — если он является константной ссылкой?
Ответ: функции с ссылкой нельзя передать символьный строковый литерал. Если ссылка константная, то при передаче больших структур или классов процесс передачи занимает много времени.