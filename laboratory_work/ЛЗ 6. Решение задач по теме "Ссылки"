Филиппов П2-17
ЛЗ 6. Решение задач по теме "Ссылки"

[1] Упражнения раздела 2.5
1) Упражнение 2.24. Какие из следующих определений (если они есть) недопустимы? Почему? Как их исправить?
(a)int ival = 1.01;
(b)int &rvall = 1.01;
(с)int &rval2 = ival;
(d)const int &rval3 = 1;

Ответ: 
b, d - неправильные т.к. ссылки должны ссылаться на обьект

2) Упражнение 2.25. Какие из следующих присвоений (если они есть) являются недопустимыми 
(с учетом предыдущих определений)? Если таковые есть, объясните, почему.
(а)rva12 = 3.14159;
(b)rva12 = rva13;
(с)ival = rval3;
(d)rval3 = ival;

Ответ:
d - неправильное, т.к. rval3 константа и ей присвоено 1 а это r-value

3) Упражнение 2.26. В чем разница между определениями (а) и присвоениями (Ь)? 
Какие из них (если есть) недопустимы?
(a)int ival = 0;	(b)ival = ri;
const int &ri = 0;	ri = ival;

Ответ:
a недопустимо т.к. ссылку следует инициализировать обьектом

4) Упражнение 2.27. Что отобразит на экране следующий код?
int i, &ri = i; i = 5; ri = 10;
std::cout << i << " " << ri << std::endl;

Ответ:
10 10

[1] Упражнения раздела 4.2.3
5) Упражнение 4.15. Укажите принципиальные различия между указателями и ссылками.

Ответ:
Указатель может быть переназначен любое количество раз, в то время как ссылка после привязки не может быть перемещена на другую ячейку памяти;
Нельзя получить адрес ссылки, как можно это делать с указателями;
Указатели могут указывать "в никуда" (быть равными NULL);
Не существует арифметики ссылок, в то время как существует арифметика указателей.

[1] Упражнения раздела 7.2.2
6) Упражнение 7.7. Объясните различие между параметрами в следующих двух объявлениях.
void f(Т);
void f(Т&);

Ответ: В первом случае T используется копия значения в функции, а во втором случае используется адрес переменной 

7) Упражнение 7.8. Приведите пример случая, когда параметр должен быть ссылочным.
Приведите пример случая, когда параметр не должен быть ссылочным.

Ответ: 
a) Пример, когда параметр должен быть ссылочным.
void swap(int &а, int &b)
{
	int t;
	t = a;
	a = b;
	b = t;
}
b) Пример, когда параметр не должен быть ссылочным.
int summ(int a, int b)
{
	return a + b;
}

8) Упражнение 7.10. Следующая функция хоть и вполне допустима, но менее полезна,
чем могла бы быть. Выявите и устраните ограничения.
bool test(string& s) { return s.empty(); } Написать main для аргументации своего решения

Ответ:
Т.к. этот параметр определён как string&, то вызвать функцию test можно только для объекта класса string, так что
int main()
{
	cout << test("Hello world");
}
привело бы к ошибке.
Проблема в том, что данная функция получает свой строковый аргумент как простую неконстантную ссылку несмотря на то, что модифицировать этот параметр не нужно.
Исправленный код:
bool test(const string& s) { return s.empty(); }

9) Упражнение 7.11. Когда ссылочные параметры должны быть константными? 
Какие проблемы могут возникнуть, если параметр является обычной ссылкой, 
а какие — если он является константной ссылкой?

Ответ:
Параметры, которые не изменяют значение соответствующего аргумента, должны быть константными ссылками.
Функции с обычной ссылкой нельзя передать символьный строковый литерал.
Одним из самых главных недостатков передачи по значению является то, что все аргументы, переданные по значению, копируются в параметры функции. 
Когда аргументами являются большие структуры или классы, то этот процесс может занять много времени.
