МДК.01.02 "Прикладное программирование"
ЛЗ 6. Решение задач по теме "Ссылки"
Составитель: Гусятинер Л.Б., 25.04.2020, МГОТУ ККМТ, П1-17, П2-17

[1] Упражнения раздела 2.5
1) Упражнение 2.24. Какие из следующих определений (если они есть) недопустимы? Почему? Как их исправить?
(a)	int ival = 1.01; ОК
(b) int &rvall = 1.01; Нельзя ссылаться на число кроме случая с const. Верный пример int &rval1 = ival;
(с)	int &rval2 = ival; OK
(d) const int &rval3 = 1; OK

2) Упражнение 2.25. Какие из следующих присвоений (если они есть) являются недопустимыми 
(с учетом предыдущих определений)? Если таковые есть, объясните, почему.
(а)	rva12 = 3.14159; ОК
(b) rva12 = rva13; OK
(с)	ival = rval3; OK
(d) rval3 = ival; ссклка rval3 имеет часть const и не может быть изменена.

3) Упражнение 2.26. В чем разница между определениями (а) и присвоениями (Ь)? 
Какие из них (если есть) недопустимы?
(a)	int ival = 0;	(b) ival = ri;
const int &ri = 0;	ri = ival;

(а) int ival = 0;
    ival = ri; ОК
    ri = ival; Если ri обявлена, то ОК

(b) const int &ri = 0;
    ri = ival; Недопустимо
    ival = ri; Если ival обявлена, то OK

4) Упражнение 2.27. Что отобразит на экране следующий код?
int i, &ri = i; i = 5; ri = 10;
std::cout << i << " " << ri << std::endl;

Вывод: 10 10

[1] Упражнения раздела 4.2.3
5) Упражнение 4.15. Укажите принципиальные различия между указателями и ссылками.

1. Ссылка не может быть не проинициализирована.
2. У ссылки нет нулевого значения.
3. Нельзя получить адрес ссылки или ссыку на ссылку.
4. Нельзя создать массив ссылок.
5. Дляссылок нет арифметики.

[1] Упражнения раздела 7.2.2
6) Упражнение 7.7. Объясните различие между параметрами в следующих двух объявлениях.

void f(Т); Передаем в функцию саму переменную T.
void f(Т&); Передаем ссылку на переменную Т.

7) Упражнение 7.8. Приведите пример случая, когда параметр должен быть ссылочным.
Приведите пример случая, когда параметр не должен быть ссылочным.

Случаи когда используются ссылки:
1. Ссылочная семантика. Иногда может быть необходимо обратиться к объекту (вне зависимости от того, как под него распределена память), 
поскольку вы хотите обратиться в функции именно в этому объекту, а не его копии — т.е. когда вам требуется реализовать передачу по ссылке.
2. Полиморфизм. Вызов функций в рамках полиморфизма (динамический класс объекта) возможен с помощью ссылки.
3. Повышение скорости компиляции. Вам может быть необходимо разделить единицы компиляции (compilation units). 
Одним из эффективных применений ссылок является предварительная декларация 
(т.к. для использования объекта вам необходимо предварительно его определить).

Случай когда ссылки не нужны:
1. Когда мы работаем в main с простыми операциями.

8) Упражнение 7.10. Следующая функция хоть и вполне допустима, но менее полезна,
чем могла бы быть. Выявите и устраните ограничения.
bool test(string& s) { return s.empty(); } Написать main для аргументации своего решения

#include <cstdlib>

using namespace std;

bool test(string &s)
{
    return s.empty();
}

int main()
{
    string s;
    getline(cin, s);
    int g = test(s);
    cout << g;
    return 0;
}

Вывод 1, если строка пуста и 0 если в строке что-то есть.

9) Упражнение 7.11. Когда ссылочные параметры должны быть константными? 
Какие проблемы могут возникнуть, если параметр является обычной ссылкой, 
а какие — если он является константной ссылкой?

Ссылочный параметр может быть константным в том случае, если нам нужно ссылаться на временный праметр(rvalue).

Проблемы если параметр обычная ссылка:
1. Нельзя переинициализировать.
2. Нет арифметики.
3. Нет 0 зачения.
4. Не может быть неинициализирована.
5. Нельзя создать массив ссылок.

Проблемы если параметр константная ссылка:

1. Все выше перечисленное кроме арифметики: const int &a = f + g; OK
2. int &a = f;
   a = g (f = g); OK

   const int &a = 1;
   a = g; Ошибка

